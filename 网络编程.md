#     1.H5新增存储方案

```javascript
	1.什么是SessionStorage和LocalStorage
    和Cookie一样, SessionStorage和LocalStorage也是用于存储网页中的数据的

    2.Cookie、 SessionStorage、LocalStorage区别
    2.1生命周期(同一浏览器下)
    Cookie生命周期:         默认是关闭浏览器后失效, 但是也可以设置过期时间
    SessionStorage生命周期: 仅在当前会话(窗口)下有效，关闭窗口或浏览器后被清除, 不能设置过期时间
    LocalStorage生命周期:   除非被清除，否则永久保存

    2.2容量
    Cookie容量:         有大小(4KB左右)和个数(20~50)限制
    SessionStorage容量: 有大小限制(5M左右) http://dev-test.nemikor.com/web-storage/support-test/
    LocalStorage容量:   有大小限制(5M左右) http://dev-test.nemikor.com/web-storage/support-test/

    2.3网络请求
    Cookie网络请求:         每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题
    SessionStorage网络请求: 仅在浏览器中保存，不参与和服务器的通信
    LocalStorage网络请求:   仅在浏览器中保存，不参与和服务器的通信

    3.Cookie、 SessionStorage、LocalStorage应用场景
    Cookie:         判断用户是否登录
    LocalStorage:   购物车
    sessionStorage: 表单数据

    4.注意点:
    无论通过以上那种方式存储的数据, 切记不能将敏感数据直接存储到本地
```

### 2.SessionStorage

```javascript
// 保存数据到 sessionStorage
sessionStorage.setItem('key', 'value');

// 从 sessionStorage 获取数据
let data = sessionStorage.getItem('key');

// 从 sessionStorage 删除保存的数据
sessionStorage.removeItem('key');

// 从 sessionStorage 删除所有保存的数据
sessionStorage.clear();
```

### 3.LocalStorage

```javascript
localStorage.setItem('myCat', 'Tom
');
                     
该语法用于读取 localStorage 项，如下:
let cat = localStorage.getItem('myCat');

该语法用于移除 localStorage 项，如下:
localStorage.removeItem('myCat');

该语法用于移除所有的 localStorage 项，如下:
// 移除所有
localStorage.clear();
```

### 4.同源策略

```javascript
 	/*
    1.什么是同源策略?
    同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能
    所谓同源是指: 协议，域名，端口都相同,就是同源, 否则就是跨域

    http://www.it666.com:80/index.html
    协议: http/https/...
    一级域名: it666.com/itzb.com
    二级域名: www/study/edu/...
    端口号: 80/3306/...

    // 协议+一级域名+二级域名+端口号都相同, 所以同源
    http://www.it666.com:80/index.html
    http://www.it666.com:80/detail.html

    // 协议不同, 所以不同源, 是跨域
    http://www.it666.com:80/index.html
    https://www.it666.com:80/index.html

    // 一级域名不同, 所以不同源, 是跨域
    http://www.it666.com:80/index.html
    http://www.itzb.com:80/index.html

    // 二级域名不同, 所以不同源, 是跨域
    http://www.it666.com:80/index.html
    http://edu.it666.com:80/index.html

    // 端口号不同, 所以不同源, 是跨域
    http://www.it666.com:80/index.html
    http://www.it666.com:8090/index.html

    2.同源策略带来的影响
    在同源策略下, 浏览器只允许Ajax请求同源的数据, 不允许请求不同源的数据
    但在企业开发中, 一般情况下为了提升网页的性能, 网页和数据都是单独存储在不同服务器上的
    这时如果再通过Ajax请求数据就会拿不到跨域数据

    3.跨域解决方案
    jsonp
    document.domain+iframe
    location.hash + iframe
    window.name + iframe
    window.postMessage
    flash等第三方插件
    * */

    /*
    当前的网页地址: http://127.0.0.1:80/jQuery/Ajax/19-%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5.html
    请求的资源地址: http://127.0.0.1:80/jQuery/Ajax/19-SameOriginPolicy.php

    当前的网页地址: http://127.0.0.1:63342/jQuery/Ajax/19-%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5.html
    请求的资源地址: http://127.0.0.1:80/jQuery/Ajax/19-SameOriginPolicy.php
    */
```

### 5.JSONP封装

```javascript
<script>
    myJSONP({
            url: "http://127.0.0.1:80/jQuery/Ajax/22-jsonp.php",
            data:{
                "teacher": "lnj",
                "age": 34
            },
            jsonp: "cb",  // 告诉jQuery服务器在获取回调函数名称的时候需要用什么key来获取
            jsonpCallback: "lnj", // 告诉jQuery服务器在获取回调函数名称的时候回调函数的名称是什么
            success: function (msg) {
                console.log(msg);
            }
        });
</script>






function obj2str(obj) {
    // 生成随机因子
    obj.t = (Math.random() + "").replace(".", "");
    let arr = [];
    for(let key in obj){
        arr.push(key + "=" + encodeURI(obj[key]));
    }
    let str = arr.join("&");
    // console.log(str);
    return str;
}
function myJSONP(options) {
    options = options || {};
    // http://127.0.0.1/jQuery/Ajax/22-jsonp.php?cb=lnj&teacher=lnj&age=34&_=1559735634387
    // http://127.0.0.1/jQuery/Ajax/22-jsonp.php?cb=lnj&teacher=lnj&age=34&t=08520581619221432
    // 1.生成URL地址
    let url = options.url;
    if(options.jsonp){
        url += "?" + options.jsonp + "=";
    }else{
        url += "?callback=";
    }

    let callbackName = ("jQuery" + Math.random()).replace(".", "");
    if(options.jsonpCallback){
        callbackName = options.jsonpCallback;
        url += options.jsonpCallback;
    }else{
        // console.log(callbackName);
        url += callbackName;
    }
    if(options.data){
        let str = obj2str(options.data);
        url += "&" + str;
    }
    // console.log(url);

    // 2.获取跨域的数据
    let oScript = document.createElement("script");
    oScript.src = url;
    document.body.appendChild(oScript);

    // 3.定义回调函数
    window[callbackName] = function (data) {
        // 删除已经获取了数据的script标签
        document.body.removeChild(oScript);
        // 将获取到的数据返回给外界
        options.success(data);
    }
}


<?php
// 0.拿到传递过来的数据
$teacher = $_GET["teacher"];
$age = $_GET["age"];
$arr = array("name"=>$teacher, "age"=>$age);
$data = json_encode($arr);

// 1.拿到回调函数的名称
//$cb = $_GET["callback"]; // jQuery112406520384710124194_1559732574283
$cb = $_GET["cb"]; // lnj
// 2.返回数据
//echo $cb."(666);"; // jQuery112406520384710124194_1559732574283(666);
echo $cb."(".$data.");"; // jQuery112406520384710124194_1559732574283(666);
?>


案例

<script>
    let $ul=$("ul");
    $("input").on("input",function(){
        $.ajax({
            url: "https://www.baidu.com/sugrec?prod=pc&from=pc_web&wd=" + this.value,
            data:{
                "teacher": "lnj",
                "age": 34
            },
            dataType:"jsonp",
            jsonp:"cb",
            success: function (msg) {
                // console.log(msg);
                createItems(msg.g);	
            }
        })
    })
    function createItems(list){
        $("ul>li").remove();
        for(let i=0;i<list.length;i++){
            let $li=$("<li>"+list[i].q+"</li>");
            $ul.append($li);
        }
    }
</script>

```

### 6.JS串行和事件循环

```javascript
 	/*
    1.JS是单线程的
    所以JS中的代码都是串行的, 前面没有执行完毕后面不能执行
    */
    /*
    2.同步代码和异步代码
    除了"事件绑定的函数"和"回调函数"以外的都是同步代码

    2.1程序运行会从上至下依次执行所有的同步代码
    2.2在执行的过程中如果遇到异步代码会将异步代码放到事件循环中
    2.3当所有同步代码都执行完毕后, JS会不断检测 事件循环中的异步代码是否满足条件
    2.4一旦满足条件就执行满足条件的异步代码
    * */
    /*
    2.为什么JS是单线程的?
    JavaScript的单线程，与它的用途有关。
    作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。
    这决定了它只能是单线程，否则会带来很复杂的同步问题。

    例如: 如果JS是多线程的
    现在有一个线程要修改元素中的内容, 一个线程要删除该元素, 这时浏览器应该以哪个线程为准？
    */
```

### 7.Promise基本概念

```javascript

 	1.什么是promise?
    promise是ES6中新增的异步编程解决方案, 在代码中的表现是一个对象


    需求: 从网络上加载3个资源, 要求加载完资源1才能加载资源2, 加载完资源2才能加载资源3
          前面任何一个资源加载失败, 后续资源都不加载

    function request(fn) {
        setTimeout(function () {
            fn("拿到的数据");
        }, 1000);
    }
    request(function (data) {
        console.log(data, 1);
        request(function (data) {
            console.log(data, 2);
            request(function (data) {
                console.log(data, 3);
            });
        });
    });
   
    2.promise作用
    企业开发中为了保存异步代码的执行顺序, 那么就会出现回调函数层层嵌套
    如果回调函数嵌套的层数太多, 就会导致代码的阅读性, 可维护性大大降低
    promise对象可以将异步操作以同步流程来表示, 避免了回调函数层层嵌套(回调地狱)

    function request() {
        return new Promise(function (resolve, reject) {
            setTimeout(function () {
                resolve("拿到的数据");
            }, 1000);
        });
    }
    request().then(function (data) {
        console.log(data, 1);
        return request();
    }).then(function (data) {
        console.log(data, 2);
        return request();
    }).then(function (data) {
        console.log(data, 3);
    });
```

### 8.Promise的基本使用

```javascript
    1.什么是Promise?
    Promise是ES6中新增的一个对象,
    通过Promise就可以实现 用同步的流程来表示异步的操作
    通过Promise就可以 避免回调函数层层嵌套(回调地狱)问题

    2.如何创建Promise对象?
    new Promise(function(resolve, reject){});
    promise对象不是异步的, 只要创建promise对象就会立即执行存放的代码

    3.Promise是如何实现 通过同步的流程来表示异步的操作的?
    promise对象是通过状态的改变来实现的, 只要状态发生改变就会自动触发对应的函数

    4.Promise对象三种状态
    pending:   默认状态，只要没有告诉promise任务是成功还是失败就是pending状态
    fulfilled(resolved): 只要调用resolve函数, 状态就会变为fulfilled, 表示操作成功
    rejected:  只要调用rejected函数, 状态就会变为rejected, 表示操作失败
    注意点: 状态一旦改变既不可逆, 既从pending变为fulfilled, 那么永远都是fulfilled
                                  既从pending变为rejected, 那么永远都是rejected

    5.监听Promise状态改变
    我们还可以通过函数来监听状态的变化
    resolved --> then()
    rejected --> catch()

    // console.log("1");
    let promise = new Promise(function (resolve, reject) {
        console.log("2");	
        reject();
        // resolve();
    });
    // console.log("3");
    // console.log(promise);
    promise.then(function () {
        console.log("then");
    });
    promise.catch(function () {
        console.log("catch");
    });
```

### 9.Promise的then方法

```javascript
    /*
    0.then方法
    then方法接收两个参数,
    第一个参数是状态切换为成功时的回调,
    第二个参数是状态切换为失败时的回调
    * */
    /*
    let promise = new Promise(function (resolve, reject) {
        // resolve(); // 将状态修改为成功
        reject(); // 将状态修改为失败
    });
    promise.then(function () {
        console.log("成功");
    }, function () {
        console.log("失败");
    });
    */

    /*
    1.then方法
    在修改promise状态时, 可以传递参数给then方法中的回调函数！！！！！！！！！！！！
    * */
    /*
    // resolve = success, reject = error;
    let promise = new Promise(function (resolve, reject) {
        // resolve("111"); // 将状态修改为成功 success("111");
        reject("aaa"); // 将状态修改为失败  error("aaa");
    });
    // promise.then(function (data) {
    //     console.log("成功", data);
    // }, function (data) {
    //     console.log("失败", data);
    // });
    function success(data) {
        console.log(data);
    }
    function error(data) {
        console.log(data);
    }
    promise.then(success, error);
    */

    /*
    2.then方法
    同一个promise对象可以多次调用then方法,
    当该promise对象的状态时所有then方法都会被执行！！！
    * */
    /*
    let promise = new Promise(function (resolve, reject) {
        // resolve(); // 将状态修改为成功
        reject(); // 将状态修改为失败
    });
    promise.then(function () {
        console.log("成功1");
    }, function () {
        console.log("失败1");
    });
    promise.then(function () {
        console.log("成功2");
    }, function () {
        console.log("失败2");
    });
    */

    /*
    3.then方法
    then方法每次执行完毕后会返回一个新的promise对象
    */
    /*
    let promise = new Promise(function (resolve, reject) {
        resolve(); // 将状态修改为成功
        // reject(); // 将状态修改为失败
    });
    let p2 = promise.then(function () {
        console.log("成功1");
    }, function () {
        console.log("失败1");
    });
    console.log(p2);
    console.log(promise === p2);
    */

   
    4.then方法
    可以通过上一个promise对象的then方法给下一个promise对象的then方法传递参数  （用return）
    注意点:
    无论是在上一个promise对象成功的回调还是失败的回调传递的参数,
    都会传递给下一个promise对象成功的回调！！！
   
   
    let promise = new Promise(function (resolve, reject) {
        // resolve("111"); // 将状态修改为成功
        reject("aaa"); // 将状态修改为失败
    });
    let p2 = promise.then(function (data) {
        console.log("成功1", data);
        return "222";
    }, function (data) {
        console.log("失败1", data);
        return "bbb";
    });
    p2.then(function (data) {
        console.log("成功2", data);
    }, function (data) {
        console.log("失败2", data);
    });
   

   
    5.then方法
    如果then方法返回的是一个Promise对象, 那么会将返回的Promise对象的
    执行结果中的值传递给下一个then方法
   
    let promise = new Promise(function (resolve, reject) {
        resolve("111"); // 将状态修改为成功
        // reject("aaa"); // 将状态修改为失败
    });
    let ppp = new Promise(function (resolve, reject) {
        // resolve("222"); // 将状态修改为成功
        reject("bbb"); // 将状态修改为失败
    });
    let p2 = promise.then(function (data) {
        console.log("成功1", data);
        return ppp;
    }, function (data) {
        console.log("失败1", data);
        return "bbb";
    });
    p2.then(function (data) {
        console.log("成功2", data);
    }, function (data) {
        console.log("失败2", data);
    });
```

### 10.Promise的catch方法

```javascript
<script>
   
    0.catch方法
    catch 其实是 then(undefined, () => {}) 的语法糖
   
    
    let promise = new Promise(function (resolve, reject) {
        // resolve(); // 将状态修改为成功
        reject(); // 将状态修改为失败
    });
    promise.catch(function () {
        console.log("abc");
    });
   

   
    2.catch方法
    注意点: 如果需要分开监听, 也就是通过then监听成功通过catch监听失败
    那么必须使用链式编程, 否则会报错
    
    
    let promise = new Promise(function (resolve, reject) {
        // resolve(); // 将状态修改为成功
        reject(); // 将状态修改为失败
    });
    // promise.then(function () {
    //     console.log("成功");
    // }).catch(function () {
    //     console.log("失败");
    // });

    promise.then(function () {
        console.log("成功");
    });
    promise.catch(function () {
        console.log("失败");
    });

    // promise.then(function () {
    //     console.log("成功");
    // }, function () {
    //     console.log("失败");
    // });
    */

    
    3.catch方法
    使用链式编程的原因是
    1.如果promise的状态是失败, 但是没有对应失败的监听就会报错
    2.then方法会返回一个新的promise, 新的promise会继承原有promise的状态
    3.如果新的promise状态是失败, 但是没有对应失败的监听也会报错
    
    let promise = new Promise(function (resolve, reject) {
        // resolve(); // 将状态修改为成功
        reject(); // 将状态修改为失败
    });
    let p2 = promise.then(function () {
        console.log("成功");
    });
    console.log(p2);
    promise.catch(function () {
        console.log("失败1");
    });
    p2.catch(function () {
        console.log("失败2");
    });

</script>
```

### 11.Promise的catch特点

```javascript
<script>

    1.catch方法
    和then一样, 在修改promise状态时, 可以传递参数给catch方法中的回调函数

    let promise = new Promise(function (resolve, reject) {
        reject("111");
    });
    promise.catch(function (data) {
        console.log(data);
    });

    2.catch方法
    和then一样, 同一个promise对象可以多次调用catch方法,
    当该promise对象的状态时所有catch方法都会被执行
   
    let promise = new Promise(function (resolve, reject) {
        reject();
    });
    promise.catch(function () {
        console.log("失败1");
    });
    promise.catch(function () {
        console.log("失败2");
    });
    promise.catch(function () {
        console.log("失败3");
    });
    
    3.catch方法
    和then一样, catch方法每次执行完毕后会返回一个新的promise对象
    
    let promise = new Promise(function (resolve, reject) {
        reject();
    });
    let p2 = promise.catch(function () {
        console.log("失败1");
    });
    console.log(p2);
    console.log(promise === p2);
    
    4.catch方法
    和then方法一样, 上一个promise对象也可以给下一个promise成功的传递参数
    注意点:
    无论是在上一个promise对象成功的回调还是失败的回调传递的参数,
    都会传递给下一个promise对象成功的回调
	//注意！！！！！！！！！！！！！！！!
  
    let promise = new Promise(function (resolve, reject) {
        reject();
    });
    let p2 = promise.catch(function () {
        console.log("失败1");
        return "it666";
    });
    p2.then(function (data) {
        console.log("成功2", data);
    }, function (data) {
        console.log("失败2", data);
    });

    5.catch方法
    和then一样, catch方法如果返回的是一个Promise对象, 那么会将返回的Promise对象的
    执行结果中的值传递给下一个catch方法

    let promise = new Promise(function (resolve, reject) {
        reject();
    });
    let ppp = new Promise(function (resolve, reject) {
        // resolve("1111");
        reject("abcd");
    });
    let p2 = promise.catch(function () {
        console.log("失败1");
        return ppp;
    });
    p2.then(function (data) {
        console.log("成功2", data);
    }, function (data) {
        console.log("失败2", data);
    });

    6.catch方法
    和then方法第二个参数的区别在于, catch方法可以捕获promise对象then方法中的异常
  
    let promise = new Promise(function (resolve, reject) {
        resolve();
    });
    // promise.then(function () {
    //     console.log("成功");
    //     xxx
    // }, function () {
    //     console.log("失败");
    // });
    promise.then(function () {
        console.log("成功");
        xxx
    }).catch(function (e) {
        console.log("失败", e);
    });
</script>
```

### 12.手撕Promise介绍

```javascript
 	/*
    1.Promise特点
    1.1创建时必须传入一个函数, 否则会报错
    1.2会给传入的函数设置两个回调函数
    1.3刚创建的Promise对象状态是pending
    1.4状态一旦发生改变就不可再次改变
    1.5可以通过then来监听状态的改变
    1.5.1如果添加监听时状态已经改变, 立即执行监听的回调
    1.5.2如果添加监听时状态还未改变, 那么状态改变时候再执行监听回到
    1.5.3同一个Promise对象可以添加多个then监听, 状态改变时所有的监听按照添加顺序执行
    */
	/*
    1.Promise特点
    1.1then方法每次执行完毕都会返回一个新的Promise对象
    1.2上一个Promise对象的then可以给下一个Promise的then传递数据
    1.2.1无论上一个是在成功的回调还是失败的回调传递的（参数）都会传递给下一个成功的回调
    1.2.2如果上一个传递的是Promise对象, 那么传给下一个的成功还是失败由传递的Promise状态决定
    */
	/*
    1.Promise特点
    1.1then方法返回的Promise对象的状态和前一个Promise的状态默认相同
    1.2后一个Promise对象的then可以捕获前一个Promise then的异常（不是一个对象）
    1.3catch方法就是then方法的语法糖 then(undefined, function(){});
    */
```

### 13.手撕Promise

```javascript
/*jshint esversion: 6 */
const PENDING="pending";
const FULFILLED="fulfilled";
const REJECTED="rejected";
class MyPromise{
    constructor(fn){
        // 0.初始化默认的状态
        this.status=PENDING;
        //定义变量保存传入的参数
        this.value=undefined;
        this.reason=undefined;
        //定义变量保存监听的函数
        // this.onResolvedCallback=null;
        // this.onRejectedCallback=null;
         this.onResolvedCallbacks=[];
        this.onRejectedCallbacks=[];
        // 1.判断传入的是否是一个函数
        if(!this._isFunction(fn)){
            throw new Error("请传入一个函数");
        }
        // 2.给函数传入两个形参（函数）以及修改当前的this
        fn(this._resolve.bind(this),this._reject.bind(this));

    }
    then(onResolved,onRejected){
        // 难点
        return new MyPromise((nextResolve,nextReject)=>{

        //判断有没有传入成功的回调
        if(this._isFunction(onResolved)){
            //判断当前状态是否发生改变  
            if(this.status===FULFILLED){
                try{
                    let result=onResolved(this.value);
                    if(result instanceof MyPromise){
                        // 由新promise的状态决定下一个的成功或失败
                        result.then(nextResolve,nextReject);
                    }else{
                        nextResolve(result);
                    }
                    
                }catch(e){
                    nextReject(e);
                }

            }
        }
        //判断有没有传入失败的回调
        // if(this._isFunction(onRejected)){
            //判断当前状态是否发生改变  
            if(this.status===REJECTED){
                try{
                    let result=onRejected(this.reason);
                    if(result instanceof MyPromise){
                        // 由新promise的状态决定下一个的成功或失败
                        result.then(nextResolve,nextReject);
                    }else if(result!==undefined){
                        nextResolve(result);
                    }else{
                        nextReject();
                    }

                }catch(e){
                    nextReject(e);
                }
            }
        // }
        //判断当前状态是否是默认状态
        if(this.status===PENDING){
            //状态未发生改变之前保存传入的回调，等状态发生改变之后再用
            if(this._isFunction(onResolved)){
                // this.onResolvedCallback=onResolved;
                this.onResolvedCallbacks.push(()=>{
                    try{
                        let result=onResolved(this.value);
                        if(result instanceof MyPromise){
                            // 由新promise的状态决定下一个的成功或失败
                            result.then(nextResolve,nextReject);
                        }else{
                            nextResolve(result);
                        }
                        
                    }catch(e){
                        nextReject();
                    }
                });
            }
            // if(this._isFunction(onRejected)){
                // this.onRejectedCallback=onRejected;
                this.onRejectedCallbacks.push(()=>{
                    try{
                        let result=onRejected(this.reason);
                        if(result instanceof MyPromise){
                            // 由新promise的状态决定下一个的成功或失败
                            result.then(nextResolve,nextReject);
                        }else if(result!==undefined){
                            nextResolve(result);
                        }else{
                            nextReject();
                        }

                    }catch(e){
                        nextReject(e);
                    }

                });
            // }
        }

        });

    }
    catch(onRejected){
        return this.then(undefined,onRejected);

    }
    _isFunction(fn){
        return typeof fn==="function";
    }  
    _resolve(value){
        if(this.status===PENDING){
            this.status=FULFILLED;
            this.value=value;
            // this.onResolvedCallback(this.value);
            this.onResolvedCallbacks.forEach((fn)=>{
                //遍历的值本身是个函数，回调函数
                fn(this.value);
            });
            //！！！
        }
    }
    _reject(reason){
        if(this.status===PENDING){
            this.status=REJECTED;
            this.reason=reason;
            // this.onRejectedCallback(this.reason);
            this.onRejectedCallbacks.forEach((fn)=>{
                fn(this.reason);
            });
        }
    }
	 static all(list){
        return new MyPromise(function(resolve,reject){
            let arr=[];
            let count=0;
            for(let i=0;i<list.length;i++){
               list[i].then(function (value) {
                       arr.push(value);
                       count++;
                       if (count === list.length) {
                           resolve(arr);
                       }
                   }).catch(function (e) {
                           reject(e);
             });
            }

        });
    }
}

let p1=new MyPromise(function(resolve,reject){
    // resolve("111");
    // reject("222");
    setTimeout(function(){
        // resolve("111");
        reject("222");
        console.log(p1);
        console.log(p2);
    },2000);
});
let newP=new MyPromise(function(resolve,reject){
    // resolve("111");
    // reject("222");
});
// p.then(function(data){
//     console.log("成功的回调1 "+data);
// },function(data){
//     console.log("失败的回调1 "+data);
// });
// p.then(function(data){
//     console.log("成功的回调2 "+data);
// },function(data){
//     console.log("失败的回调2 "+data);
// });

let p2=p1.then(function(data){
    console.log("成功的回调1 "+data);
    // return "222";
    // return newP;
    
},function(data){
    console.log("失败的回调1 "+data);
    // return "333";
    // return newP;
});

// p2.then(function(data){
//     console.log("成功的回调2 "+data);
// },function(data){
//     console.log("失败的回调2 "+data);
// });

p2.then(function(data){
    console.log("成功的回调2 "+data);
});
p2.catch(function(){
    console.log("catch");
});

console.log(p1);
console.log(p2);
  
```

### 14.Promise练习

```javascript
<script>
        /*
        需求:
        一次加载一张图片添加到body中. 前面图片加载失败后面图片不加载
        */
        let arr = [
        "http://www.it666.com/files/system/block_picture_1555415767.png",
        "http://www.it666.com/files/system/block_picture_1555422597.jpg",
        "http://www.it666.com/files/system/block_picture_1555419713.jpg"
    ];
    function loadImg(url){
        return new MyPromise(function(resolve,reject){
            let oImg=new Image();
            oImg.src=url;
            oImg.onload=function(){
                resolve(oImg);
            }
            oImg.onerror=function(){
                reject("加载失败");
            }
        });
    }
    loadImg(arr[0]).then(function(oImg){
        document.body.appendChild(oImg);
        return loadImg(arr[1]);
    }).then(function(oImg){
        document.body.appendChild(oImg);
        return loadImg(arr[2]);
    }).then(function(oImg){
        document.body.appendChild(oImg);
    }).catch(function(e){
        console.log(e);
    })


    </script>
```

### 15.Promise-all方法

```javascript
 /*
    需求:
    1.无序加载图片, 每加载成功一张就添加一张
    2.无序加载图片, 只有所有图片都加载成功才添加, 有一张图片失败都不添加
    */
    let arr = [
        "http://www.it666.com/files/system/block_picture_1555415767.png",
        "http://www.it666.com/files/system/block_picture_1555422597.jpg",
        "http://www.it666.com/files/system/block_picture_1555419713.jpg"
    ];
    function loadImage(url) {
        return new Promise(function (resolve, reject) {
            let oImg = new Image();
            let time = Math.random() * 1000;
            // console.log(time);
            setTimeout(function () {
                oImg.src = url;
            }, time);
            // oImg.src = url;
            oImg.onload = function () {
                resolve(oImg);
            }
            oImg.onerror = function () {
                reject("图片加载失败了");
            }
        });
    }
    /*
    for(let i = 0; i < arr.length; i++){
        loadImage(arr[i]).then(function (oImg) {
            console.log(i);
            document.body.appendChild(oImg);
        }, function (msg) {
            console.log(msg);
        });
    }
    */
    /*
    Promise的all静态方法:
    1.all方法接收一个数组,
    2.如果数组中有多个Promise对象,只有都成功才会执行then方法,
    并且会按照添加的顺序, 将所有成功的结果重新打包到一个数组中返回给我们
    3.如果数组中不是Promise对象, 那么会直接执行then方法

    应用场景: 批量加载, 要么一起成功, 要么一起失败
    * */
    /*
    let p1 = new Promise(function (resolve, reject) {
        // resolve("111");
        reject("aaa");
    });
    let p2 = new Promise(function (resolve, reject) {
        setTimeout(function () {
            resolve("222");
        }, 5000);
    });
    let p3 = new Promise(function (resolve, reject) {
        setTimeout(function () {
            resolve("333");
        }, 3000);
    });
    Promise.all([p1, p2, p3]).then(function (result) {
        console.log("成功", result);
    }, function (err) {
        console.log("失败", err);
    });
    */

    Promise.all([loadImage(arr[0]), loadImage(arr[1]),loadImage(arr[2])])
        .then(function (result) {
            // console.log(result);
            result.forEach(function (oImg) {
                document.body.appendChild(oImg);
            });
        })
        .catch(function (e) {
            console.log(e);
        });
```

### 16.Promise-all方法封装

```javascript
 static all(list){
        return new MyPromise(function(resolve,reject){
            let arr=[];
            let count=0;
            for(let i=0;i<list.length;i++){
               list[i].then(function (value) {
                       arr.push(value);
                       count++;
                       if (count === list.length) {
                           resolve(arr);
                       }
                   }).catch(function (e) {
                           reject(e);
             });
            }

        });
    }




 Promise.all([loadImage(arr[0]), loadImage(arr[1]),loadImage(arr[2])])
        .then(function (result) {
            // console.log(result);
            result.forEach(function (oImg) {
                document.body.appendChild(oImg);
            });
        })
        .catch(function (e) {
            console.log(e);
        });
```

### 17.Promise-race方法

```javascript
 	Promise的race静态方法:
    1.race方法接收一个数组,
    2.如果数组中有多个Promise对象, 谁先返回状态就听谁的, 后返回的会被抛弃
    3.如果数组中不是Promise对象, 那么会直接执行then方法

    应用场景: 接口调试, 超时处理

	let url = "http://www.it666.com/files/system/block_picture_1555415767.png";
    
	function loadImage(url) {
        return new Promise(function (resolve, reject) {
            let oImg = new Image();
            setTimeout(function () {
                oImg.src = url;
            }, 5000);
            oImg.onload = function () {
                resolve(oImg);
            }
            oImg.onerror = function () {
                reject("图片加载失败了");
            }
        });
    }
    function timeout() {
        return new Promise(function (resolve, reject) {
            setTimeout(function () {
                reject("超时了");
            }, 3000);
        });
    }
    Promise.race([loadImage(url), timeout()]).then(function (value) {
        console.log("成功", value);
    }).catch(function (e) {
        console.log("失败", e);
    });
```

### 18.Promise-race方法实现

```javascript
    static race(list){
        return new MyPromise(function(resolve,reject){
            for(let p of list){
                p.then(function(value){
                    resolve(value);
                }).catch(function(e){
                    reject(e);
                })
            }
        });
    }



    /*
    1.Promise的race静态方法特点
    1.1race方法会返回一个新的Promise对象
    1.2谁先返回就听谁的
    */
    let p1 = new MyPromise(function (resolve, reject) {
        // resolve("111");
        reject("aaa");
    });
    let p2 = new MyPromise(function (resolve, reject) {
        setTimeout(function () {
            resolve("222");
            // reject("bbb");
        }, 5000);
    });
    let p3 = new MyPromise(function (resolve, reject) {
        setTimeout(function () {
            resolve("333");
            // reject("ccc");
        }, 3000);
    });
    MyPromise.race([p1, p2, p3]).then(function (value) {
        console.log("成功", value);
    }).catch(function (e) {
        console.log("失败", e);
    });
```

### 19.Promise改造ajax

```javascript
<script>
    function obj2str(data) {
        data = data || {};
        data.t = new Date().getTime();
        var res = [];
        for(var key in data){
            res.push(encodeURIComponent(key)+"="+encodeURIComponent(data[key]));
        }
        return res.join("&");
    }
    function ajax(option) {
        return new Promise(function (resolve, reject) {
            // 0.将对象转换为字符串
            var str = obj2str(option.data);
            // 1.创建一个异步对象
            var xmlhttp, timer;
            if (window.XMLHttpRequest){
                xmlhttp=new XMLHttpRequest();
            }else{
                xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
            }
            // 2.设置请求方式和请求地址
            if(option.type.toLowerCase() === "get"){
                xmlhttp.open(option.type, option.url+"?"+str, true);
                // 3.发送请求
                xmlhttp.send();
            }else{
                xmlhttp.open(option.type, option.url,true);
                // 注意点: 以下代码必须放到open和send之间
                xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");
                xmlhttp.send(str);
            }

            // 4.监听状态的变化
            xmlhttp.onreadystatechange = function (ev2) {
                if(xmlhttp.readyState === 4){
                    clearInterval(timer);
                    // 判断是否请求成功
                    if(xmlhttp.status >= 200 && xmlhttp.status < 300 ||
                        xmlhttp.status === 304){
                        // 5.处理返回的结果
                        // console.log("接收到服务器返回的数据");
                        // option.success(xmlhttp);
                        resolve(xmlhttp);
                    }else{
                        // console.log("没有接收到服务器返回的数据");
                        // option.error(xmlhttp);
                        reject(xmlhttp);
                    }
                }
            }
            // 判断外界是否传入了超时时间
            if(option.timeout){
                timer = setInterval(function () {
                    console.log("中断请求");
                    xmlhttp.abort();
                    clearInterval(timer);
                }, option.timeout);
            }
        });
    }
</script>
<script>
    ajax({
        type:"post",
        url:"40.php",
        // success: function (xhr) {
        //     let str = xhr.responseText;
        //     let json = JSON.parse(str);
        //     console.log(json);
        // },
        // error: function (xhr) {
        //     console.log(xhr.status);
        // }
    }).then(function (xhr) {
        let str = xhr.responseText;
        let json = JSON.parse(str);
        console.log(json);
    }).catch(function (xhr) {
        console.log(xhr.status);
    });
</script>
```

![批注 2020-11-25 171549](%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/%E6%89%B9%E6%B3%A8%202020-11-25%20171549.png)

### 20.fetch网络请求-ES6

```javascript
    /*
    1.什么是fetch?
    和Ajax一样都是用于请求网络数据的
    fetch是ES6中新增的, 基于Promise的网络请求方法

    2.fetch基本使用
    fetch(url, {options})
    .then()
    .catch();

    http://127.0.0.1/jQuery/Ajax/41.php
    */
    /*
    fetch("http://127.0.0.1/jQuery/Ajax/41.php?teacher=lnj&age=34", {
        method: "get"
    }).then(function (res) {
        // console.log(res.text());
        // return res.text();
        return res.json();
    }).then(function (data) {
        console.log(data);
        console.log(typeof data);
    }).catch(function (e) {
        console.log(e);
    });
    */
    fetch("http://127.0.0.1/jQuery/Ajax/41.php", {
        method: "post",
        body: JSON.stringify({teacher:"zq", age:666})
    }).then(function (res) {
        // console.log(res.text());
        // return res.text();
        return res.json();
    }).then(function (data) {
        console.log(data);
        console.log(typeof data);
    }).catch(function (e) {
        console.log(e);
    });
```

### 21.fetch封装

```javascript
<?php
//echo "it666";

//$teacher = $_GET["teacher"];
//$age = $_GET["age"];
//$arr = array("name"=>$teacher, "age"=>$age);
//$data = json_encode($arr);
//echo $data;

$rws_post = $GLOBALS["HTTP_RAW_POST_DATA"];
$mypost = json_decode($rws_post);
$teacher = (string)$mypost->teacher;
$age = (string)$mypost->age;
$arr = array("name"=>$teacher, "age"=>$age);
$data = json_encode($arr);
echo $data;

   class EasyHttp{
        static obj2str(data) {
            data = data || {};
            data.t = new Date().getTime();
            var res = [];
            for(var key in data){
                res.push(encodeURIComponent(key)+"="+encodeURIComponent(data[key]));
            }
            return res.join("&");
        }
        static get(url, params){
            return new Promise(function (resolve, reject) {
                let newUrl = url;
                if(params !== undefined && params instanceof Object){
                    let str = EasyHttp.obj2str(params);
                    newUrl += "?" + str;
                }                   
                fetch(newUrl, {
                    method: "get"
                }).then(function (res) {
                    resolve(res.json());
                }).catch(function (e) {
                    reject(e);
                })
            })
        }
        static post(url, params){
            return new Promise(function (resolve, reject) {
                fetch(url, {
                    method: "post",
                    body: JSON.stringify(params)
                }).then(function (res) {
                    resolve(res.json());
                }).catch(function (e) {
                    reject(e);
                })
            })
        }
    }
    let obj = {
        teacher: "lnj",
        age: 34
    }
    EasyHttp.post("http://127.0.0.1/jQuery/Ajax/41.php", obj)
    .then(function (data) {
        console.log(data);
    })
    .catch(function (e) {
        console.log(e);
    });
```

### 22.Axios插件的使用

```javascript

    // 1.什么是axios?
    // Axios 是一个基于 promise 的 HTTP 库网络请求插件

    // 2.axios特点
    // 2.1可以用在浏览器和 node.js 中
    // 2.2支持 Promise API
    // 2.3自动转换 JSON 数据
    // 2.4客户端支持防御 XSRF

    // axios.get("http://127.0.0.1/jQuery/Ajax/41.php")
    axios.get("./41.php?teacher=lnj&age=18")
        // axios.post("./41.php", {
        //     teacher: "lnj",
        //     age: 666
        // })
        .then(function (res) {
            console.log(res.data);
        })
        .catch(function (e) {
            console.log(e);
        });


    /*
    3.全局的 axios 默认值
    在企业开发中项目分为 :开发阶段和部署阶段, 这两个阶段项目存储的位置是不同的
    项目上线前存储在企业内部测试服务器上, 项目上线后存储在企业正式服务器上
    所以如果每次请求都将请求的地址写在请求中, 那么项目上线时需要大量修改请求地址
    为了解决这个问题, 我们可以配置一个全局URL根地址, 项目上线时只需要修改根地址即可
    例如: 上线前地址是: http://127.0.0.1/jQuery/Ajax/41.php
          上线后地址是: http://192.199.13.14/jQuery/Ajax/41.php
    */
    // axios.defaults.timeout = 2000;
	//全局请求超时时间
    // axios.defaults.baseURL = "http://127.0.0.1";
    // axios.post("NewJS/41.php", {
    //     teacher: "lnj",
    //     age: 666
    // })
    //     .then(function (res) {
    //         console.log(res.data);
    //     })
    //     .catch(function (e) {
    //         console.log(e);
    //     });




<?php
//echo "it666";

$teacher = $_GET["teacher"];
$age = $_GET["age"];
$arr = array("name"=>$teacher, "age"=>$age);
$data = json_encode($arr);
echo $data;

// $rws_post = $GLOBALS["HTTP_RAW_POST_DATA"];
// $mypost = json_decode($rws_post);
// $teacher = (string)$mypost->teacher;
// $age = (string)$mypost->age;
// $arr = array("name"=>$teacher, "age"=>$age);
// $data = json_encode($arr);
// echo $data;
```

## 23.Symbol-基本数据类型

```javascript
  /*
    1.什么Symbol?
    Symbol是ES6中新增的一种数据类型, 被划分到了基本数据类型中
    基本数据类型: 字符串、数值、布尔、undefined、null、Symbol
    引用数据类型: Object

    2.Symbol的作用
    用来表示一个独一无二的值

    3.如果生成一个独一无二的值?
    let xxx = Symbol();
    */
    /*
    4.为什么需要Symbol?
    在企业开发中如果需要对一些第三方的插件、框架进行自定义的时候
    可能会因为添加了同名的属性或者方法, 将框架中原有的属性或者方法覆盖掉
    为了避免这种情况的发生, 框架的作者或者我们就可以使用Symbol作为属性或者方法的名称

    5.如何区分Symbol?
    在通过Symbol生成独一无二的值时可以设置一个标记
    这个标记仅仅用于区分, 没有其它任何含义
    */
    // let xxx = Symbol();
    // let yyy = Symbol();
    // console.log(xxx === yyy);

    /*
    let obj = {
        name: "lnj",
        say: function () {
            console.log("say");
        }
    }
    obj.name = "it666";
    console.log(obj.name);
    obj.say = function () {
        console.log("test");
    }
    obj.say();
    */
    let name = Symbol("name");
    let say = Symbol("say");
    let obj = {
        // 注意点: 如果想使用变量作为对象属性的名称, 那么必须加上[]
        [name]: "lnj",
        [say]: function () {
            console.log("say");
        }
    }
    // obj.name = "it666";
    obj[Symbol("name")] = "it666";
    console.log(obj);
```

### 24.Symbol注意点

```javascript
// 1.通过Symbol生成独一无二值时需要在后面加上(), 但是前面不能加new, 因为它不是引用类型
    // let xxx = Symbol(); // 正确
    // let xxx = new Symbol(); // 错误

    // 2.通过Symbol生成独一无二值时传入的字符串仅仅是一个标记, 方便我们阅读代码, 没有其它任何意义
    // let xxx = Symbol("name");

    // 3.做类型转换的时候不能转换成数值
    // let xxx = Symbol("name");
    // console.log(String(xxx));
    // console.log(Boolean(xxx));
    // console.log(Number(xxx));

    // 4.不能做任何运算
    // let xxx = Symbol("name");
    // console.log(xxx + "abc");
    // console.log(xxx + 123);

    // 5.Symbol生成的值作为属性或方法名称时, 一定更要保存下来, 否则后续无法使用
    // let name = Symbol("name");
    // let obj = {
    //     // [name]: "lnj"
    //     [Symbol("name")]: "it666"
    // }
    // // console.log(obj[name]);
    // console.log(obj[Symbol("name")]);

    // 6.for循环无法遍历出Symbol的属性和方法
    let name = Symbol("name");
    let say = Symbol("say");
    let obj = {
        // 注意点: 如果想使用变量作为对象属性的名称, 那么必须加上[]
        [name]: "lnj",
        [say]: function () {
            console.log("say");
        },
        age: 34,
        gender: "man",
        hi: function () {
            console.log("hi");
        }
    }
    // for(let key in obj){
    //     console.log(key);
    // }
    console.log(Object.getOwnPropertySymbols(obj));
```

### 25.Iterator接口

```javascript
 /*
    1.什么是Iterator?
    Iterator又叫做迭代器, 是一种接口
    这里的接口和现实中接口一样, 是一种标准一种规范
    例如: 电脑的USB接口有电脑USB接口的标准和规范, 正式因为有了标准和规范
          所以A厂商生成的USB线可以插到B厂商电脑的USB接口上

    它规定了不同数据类型统一访问的机制, 这里的访问机制主要指数据的遍历
    在ES6中Iterator接口主要供for...of消费

    2.默认情况下以下数据类型都实现的Iterator接口
    Array/Map/Set/String/TypedArray/函数的 arguments 对象/NodeList 对象
    */
    /*
    1.只要一个数据已经实现了Iterator接口, 那么这个数据就有一个叫做[Symbol.iterator]的属性
    2.[Symbol.iterator]的属性会返回一个函数
    3.[Symbol.iterator]返回的函数执行之后会返回一个对象
    4.[Symbol.iterator]函数返回的对象中又一个名称叫做next的方法
    5.next方法每次执行都会返回一个对象{value: 1, done: false}
    6.这个对象中存储了当前取出的数据和是否取完了的标记
    */
    /*
    // let arr = [1, 3, 5];
    // console.log(arr[Symbol.iterator]);
    // let it = arr[Symbol.iterator]();
    // console.log(it);
    // console.log(it.next());
    // console.log(it.next());
    // console.log(it.next());
    // console.log(it.next());

    // for(let value of arr){
    //     console.log(value);
    // }

    // let obj = {
    //     name: "lnj",
    //     age: 34,
    //     gender: "man"
    // }
    // console.log(obj[Symbol.iterator]);
    // for(let value of obj){
    //     console.log(value);
    // }
    */

    class MyArray{
        constructor(){
            for(let i = 0; i < arguments.length; i++){
                // this[0] = 1;
                // this[1] = 3;
                // this[2] = 5;
                this[i] = arguments[i];
            }
            this.length = arguments.length;
        }
        [Symbol.iterator](){
            let index = 0;
            let that = this;
            return {
                next(){
                    if(index < that.length){
                        return {value: that[index++], done: false}
                    }else{
                        return {value: that[index], done: true}
                    }
                }
            }
        }
    }
    let arr = new MyArray(1, 3, 5);
    // console.log(arr);
    // console.log(arr[0]);
    // arr[0] = 666;
    // console.log(arr);
    for(let value of arr){
        console.log(value);
    }
    // console.log(arr[Symbol.iterator]);
    // let it = arr[Symbol.iterator]();
    // console.log(it);
    // console.log(it.next());
    // console.log(it.next());
    // console.log(it.next());
    // console.log(it.next());
```



### 26.Iterrator应用场景

```javascript
// 1.解构赋值
    class MyArray{
        constructor(){
            for(let i = 0; i < arguments.length; i++){
                // this[0] = 1;
                // this[1] = 3;
                // this[2] = 5;
                this[i] = arguments[i];
            }
            this.length = arguments.length;
        }
        [Symbol.iterator](){
            let index = 0;
            let that = this;
            return {
                next(){
                    if(index < that.length){
                        return {value: that[index++], done: false}
                    }else{
                        return {value: that[index], done: true}
                    }
                }
            }
        }
    }
    // let arr = [1, 3];
    // let arr = new MyArray(1, 3);
    // let [x, y, z] = arr;
    // console.log(x, y, z);

    // 2.扩展运算符
    // let arr1 = [1, 3];
    // let arr2 = [2, 4];
    let arr1 = new MyArray(1, 3);
    let arr2 = new MyArray(2, 4);
    let arr3 = [...arr1, ...arr2];
    console.log(arr3);
```

### 27.Generator函数

```javascript
 /*
    1.什么是Generator函数?
    Generator 函数是 ES6 提供的一种异步编程解决方案
    Generator 函数内部可以封装多个状态, 因此又可以理解为是一个状态机

    2.如何定义Generator函数
    只需要在普通函数的function后面加上*即可

    3.Generator函数和普通函数区别
    3.1调用Generator函数后, 无论函数有没有返回值, 都会返回一个迭代器对象,
    3.2调用Generator函数后, 函数中封装的代码不会立即被执行

    4.真正让Generator具有价值的是yield关键字
    4.1在Generator函数内部使用yield关键字定义状态
    4.2并且yield关键字可以让 Generator内部的逻辑能够切割成多个部分。
    4.3通过调用迭代器对象的next方法执行一个部分代码,
       执行哪个部分就会返回哪个部分定义的状态

    5.在调用next方法的时候可以传递一个参数, 这个参数会传递给上一个yield
    */
    function* gen() {
        console.log("123");
        let res = yield "aaa";

        console.log(res);
        console.log("567");
        yield 1 + 1;

        console.log("789");
        yield true;
    }
    let it = gen();
    // console.log(it);
    console.log(it.next());
    console.log(it.next("it666"));
    // console.log(it.next());
    // console.log(it.next());

    // 注意点: yield关键字只能在Generator函数中使用, 不能在普通函数中使用
    // function say() {
    //     yield "abc";
    // }
    // say();
```

### 28.Generator函数应用场景

```javascript
  /*
    应用场景, 让函数返回多个值
    * */
    /*
    function calculate(a, b) {
        let sum = a + b;
        let sub = a - b;
        return [sum, sub];
    }
    */
    function* calculate(a, b) {
        yield a + b;
        yield a - b;
    }
    let it = calculate(10, 5);
    console.log(it.next().value);
    console.log(it.next().value);










/*
    1. 应用场景: 利用 Generator 函数，可以在任意对象上快速部署 Iterator 接口
    */
    /*
    Generator 函数特点
    1.Generator 函数也是一个函数
    2.Generator 函数会返回一个迭代器对象
    3.迭代器对象有next方法
    4.next方法每次执行都会返回一个对象{value: xxx, done: false}
    */
    /*
    function* gen() {
        yield "aaa";
        yield "bbb";
        yield "ccc";
    }
    let it = gen();
    // console.log(it);
    console.log(it.next());
    */

    /*
   1.必须有一个叫做[Symbol.iterator]的属性
   2.[Symbol.iterator]的属性会返回一个函数
   3.[Symbol.iterator]返回的函数执行之后会返回一个可迭代对象
   4.[Symbol.iterator]函数返回的对象中又一个名称叫做next的方法
   5.next方法每次执行都会返回一个对象{value: xxx, done: false}
   */
    /*
    let obj = {
        name: "lnj",
        age: 34,
        gender: "man",
        [Symbol.iterator](){
            let keys = Object.keys(this);
            // console.log(keys);
            let index = 0;
            let that = this;
            return {
                next(){
                    if(index < keys.length){
                        return {value: that[keys[index++]], done: false};
                    }else{
                        return {value: undefined, done: true};
                    }
                }
            }
        }
    }
    // console.log(obj[Symbol.iterator]);
    // let it = obj[Symbol.iterator]();
    // console.log(it);
    // console.log(it.next());
    // console.log(it.next());
    // console.log(it.next());
    // console.log(it.next());
    for(let value of obj){
        console.log(value);
    }
    */

    let obj = {
        name: "lnj",
        age: 34,
        gender: "man"
    }
    function* gen(){
        let keys = Object.keys(obj);
        for(let i = 0; i < keys.length; i++){
            yield obj[keys[i]];
        }
    }
    obj[Symbol.iterator] = gen;
    // console.log(obj[Symbol.iterator]);
    let it = obj[Symbol.iterator]();
    // console.log(it);
    console.log(it.next());
    console.log(it.next());
    console.log(it.next());
    console.log(it.next());












/*
    应用场景: 用同步的流程来表示异步的操作
    */
    /*
    function request(fn) {
        setTimeout(function () {
            fn("拿到的数据");
        }, 1000);
    }
    request(function (data) {
        console.log("1", data);
        request(function (data) {
            console.log("2", data);
            request(function (data) {
                console.log("3", data);
            });
        });
    });
    */
    function request() {
        return new Promise(function (resolve, reject) {
            setTimeout(function () {
                resolve("拿到的数据");
            }, 1000);
        });
    }
    /*
    request().then(function (data) {
        console.log(data, 1);
        return request();
    }).then(function (data) {
        console.log(data, 2);
        return request();
    }).then(function (data) {
        console.log(data, 3);
    });
    */
    function* gen() {
        yield request();
        yield request();
        yield request();
    }
    let it = gen();
    // console.log(it.next().value);
    it.next().value.then(function (data) {
        console.log(data, 1);
        return it.next().value;
    }).then(function (data) {
        console.log(data, 2);
        return it.next().value;
    }).then(function (data) {
        console.log(data, 3);
    });
```

### 29.-async-await

```javascript
 function request() {
        return new Promise(function (resolve, reject) {
            setTimeout(function () {
                resolve("拿到的数据");
            }, 1000);
        });
    }
    /*
    function* gen() {
        yield request();
        yield request();
        yield request();
    }
    let it = gen();
    it.next().value.then(function (data) {
        console.log(data, 1);
        return it.next().value;
    }).then(function (data) {
        console.log(data, 2);
        return it.next().value;
    }).then(function (data) {
        console.log(data, 3);
    });
    */
    async function gen() {
        let res1 = await request();
        console.log(res1, 1);
        let res2 = await request();
        console.log(res2, 2);
        let res3 = await request();
        console.log(res3, 3);
    }
    gen();
    /*
    1.async函数
    async函数是ES8中新增的一个函数, 用于定义一个异步函数
    async函数函数中的代码会自动从上至下的执行代码

    2.await操作符
    await操作符只能在异步函数 async function 中使用
    await表达式会暂停当前 async function 的执行，等待 Promise 处理完成。
    若 Promise 正常处理(fulfilled)，其回调的resolve函数参数作为 await 表达式的值，然后继续执行 async function。
    * */
```

### 30.

```javascript

```

