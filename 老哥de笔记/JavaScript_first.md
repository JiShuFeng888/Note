# JavaScript_first

## 梗概

### JavaScript 的三个部分

三部分: ECMAScript, DOM, BOM

### 书写格式

1. CSS书写格式
   1. 行内样式: 写在标签内部
   2. 内嵌样式(内联样式) : 写在一对head标签中
   3. 外链样式: 写在一个单独的.css文件中, 再导入进来
2. JavaScript**书写格式**
   1. **行内**样式: 写在标签内部
   2. **内嵌**样式(内联样式) : 写在一对 head 标签中
   3. **外链**样式: 写在一个单独的 **.js** 文件中, 再导入进来
3. JavaScript书写**格式注意点** (js 是单线程的)
   1. 不推荐直接将 JavaScript 代码书写到标签内部
   2. 默认情况下浏览器会从上至下的解析网页, 所以如果将 JavaScript 写到一对 **head** 标签中, 并且需要**通过 JavaScript 代码操作界面上的元素**, 那么就**不能直接书写**JavaScript代码, 否则无效
      1. 如果想将 JavaScript 写到一对 head 标签中, 且需要在JavaScript代码中操作界面上的元素, 则必须加上window.onload = function(){操作界面元素的JavaScript}
      2. **<font color="red">window.onload</font>的含义: 等到界面上所有的内容都加载完毕再执行 {} 中的代码**
      3. 由于默认情况下浏览器会从上至下的解析网页, 所以如果想通过 JavaScript 操作界面上的元素只需要**等到元素被加载解析之后**操作就可以了, 所以我们还可以将 JavaScript 代码写到 body 结束标签的前面
   3. **如果**通过外链式导入 .js 文件, 并且需要在 .js 文件中操作界面上的元素, 那么如果是在 head 标签中导入的, **必须**在 .js 文件中加上 window.onload. 如果是在 body 结束标签前面导入的, 就不用添加 window.onload
   4. 如果需要在一对 script 标签中编写 JavaScript 代码, 就**不能同时**通过 script 标签再导入其它的 .js 文件, 否则书写的 JavaScript 代码无效

### 三种输出方式

1. 通过**弹窗**的形式来输出
   - alert(需要输出的内容);
   - confirm(需要输出的内容);
   - prompt(需要输出的内容);
     prompt 的返回值是字符串, 所以在使用 prompt 和三等号时注意转换类型
   - 注意点:
     - **如果需要输出的内容不是数字, 那么就<font color="red">必须</font>通过单引号或者双引号括起来**
     - 在 <font color="red">JavaScript 中是严格区分大小写的</font>, alert() 和 ALERT() 不是一回事
     - 在编写 JavaScript 代码的时候, 一定要记住每一句代码后面都需要添加一个分号, 并且这个分号必须是**英文的分号**
     - 我们会发现有时候不写分号程序也能够运行, 这里并不是因为不需要分号, 而是浏览器自动帮助我们添加了分号, **浏览器自动添加会消耗一定的性能, 并且有可能会添加错误**
2. 过**网页内容区域**的形式来输出
   - document.write(需要输出的内容);
   - 注意点:
     - 如果需要输出的内容不是数字, 那么就必须通过单引号或者双引号括起来
3. 通过**开发者工具控制台**的形式来输出
   - console.log(需要输出的内容); // 普通输出
   - console.warn(需要输出的内容); // 警告输出, 背景变黄, 行首有三角叹号
   - console.error(需要输出的内容); // 错误输红出, 背景变, 行首有圆形叉号
   - 注意点:
     - 如果需要输出的内容不是数字, 那么就必须通过单引号或者双引号括起来

## ECMAScript (ES)

### 各种字

- 常量
- 变量
- 关键字和保留字 (Keywords & Reserved word)
- 标识符 (Identifier)
- 注释

#### 常量

能用常量就别用变量, 省心

1. 什么是常量?
   常量表示一些<font color="red">固定不变</font>的数据
   现实生活中人的性别其实就可以看做是常量, 生下来是男孩一辈子都是男孩, 生下来是女孩一辈子都是女孩
2. JavaScript中常量的分类
   1. **整型**常量
      整型常量其实就是正数, 在JavaScript中随便写一个整数都是整型常量
      1  /  666 /  99
   2. **实型**常量
      实型常量其实就是小数, 在JavaScript中随便写一个小数都是实型常量
      3.14  6.66
   3. **字符串**常量
      字符串常量其实就是用单引号<font color="red">或者</font>双引号括起来的内容, 我们就称之为字符串常量 (这点和 java 蛮不一样)
      'a'
      'abc'
      "1"
      "知播渔教育"
      - 注意点: 无论用单引号或者双引号括起来了多少个字符, 在JavaScript中都是字符串常量
   4. **布尔**常量
      布尔常量其实就是真或者假, 在JavaScript中通过true和false来表达
      在JavaScript中布尔常量只有两个取值, 真(true)或者假(false)
   5. **自定义**常量
      在ES6中新增的
      const 常量名称 = 常量取值;

**补充**:

每个常量必定有其数据类型

#### 变量

##### 简介

1. 什么是变量?
   变量表示一些可以被修改的数据
   在现实生活中超市的储物格就是变量, 在不同的时间段里面, 储物格中存储的数据也不一样
2. 如何定义一个变量
   在JavaScript中可以通过定义变量的方式来生成储物格, 也就是告诉浏览器, 我们需要一块内存空间
   var 变量名称;
3. 如何使用变量
   使用变量就是往申请的那块内存空间中存储数据, 和获取存储的数据
   1. 如何存储数据
      变量名称 = 需要存储的数据;
      可以将等号右边需要存储的数据放到等号左边变量申请的那块存储空间中
   2. 如何获取存储在变量中的数据
      变量名称

##### 补充

- 在JavaScript中第一次给变量赋值, 我们称之为"变量的初始化"
- 在JavaScript中如果定义了一个变量,但是没有进行初始化, 那么变量中存储的是 undefined
- 给变量初始化有很多种形式
  1. **先**定义变量, **再**对变量进行初始化
     var num, value;
     num = 123;
     value = 666;
  2. 可以在定义变量的**同时**对变量进行初始化
     var num =123;
- **同时**定义多个变量: var 变量名称1, 变量名称2, .... ;
- **同时**初始化多个变量: 变量名称1 = 变量名称2 = 变量名称... = 初始化值;

##### 变量注意点

(2 和 3 是 ES6 以前的垃圾特性)

1. 在JavaScript中变量之间是可以**相互赋值**的
2. 在JavaScript中如果定义了同名的变量, 后定义的变量会覆盖先定义的变量
   var num = 666;
   num = 888; // 如果num前面没有var, 那么就是修改变量中存储的值
   var num = 888;// 如果num前面有var, 那么就**不是**修改变量中存储的值, 而是重新定义一个新的变量
3. 在**老版本**的标准的(ES6之前)JavaScript中可以先使用变量, 再定义变量, 并不会报错
   由于JavaScript是一门解释型的语言, 会边解析边执行, 浏览器在解析JavaScript代码之前还会进行一个操作"**预解析**(预处理)"
   预解析(预处理)步骤:
   将当前JavaScript代码中所有变量的定义和函数的定义放到所有代码的最前面

##### ES6 对变量的补救

为了解决老板标准的的注意点的 2 和 3
在ES6中就推出了一种**新的定义变量的方式**
格式:

- ES6之前: var 变量名称;
- ES6开始: let 变量名称;

// 定义一个变量

​    let num;

// 给变量初始化

​    num = 666;

```js
var num = 123;
var num = 888; // 老版本中这么写没问题
```

```js
let num = 123;
let num = 888; //会明确的报错
```

#### 字面量

*Literals* represent values in JavaScript. **These are fixed values**—not variables—that you *literally* provide in your script.

- Array literals
- Boolean literals
- Floating-point literals
- Numeric literals
- Object literals
- RegExp literals
- String literals

#### 数据类型

javascript 的七种基本数据类型

##### 六种基本数据类型

- `undefined` | 只有一个**取值** undefined, 未初始化的变量中保存的是 undefined
- `null` | 空类型 (空类型与对象类型是关联在一起的)
- `string` | 在JavaScript中无论是通过**单**引号还是通过**双**引号括起来的内容都是属于字符串类型的
- `boolean` | 只有两个取值true/false
- `number` | 在JavaScript中无论是整数还是小数都是属于数值类型的
- `symbol(ES6)` | ES6 新增

一种引用类型

- `Object` | 对象类型

##### typeof 操作符

利用 typeof 检测123 这个常量是属于哪一种数据类型的, 并且将检测的结果保存到res这个变量中

​    // let res = typeof 123;

​    // let res = typeof 3.14;

**注意点**:

- 对 null 做 typeof 运算会得到 object

  ```js
  let a = null;
  let b = typeof a;
  console.log(b); // object
  ```

- undefined 的特殊之处在于 undefined 这个类型只有一个取值, 这唯一的取值就是 undefined

- 对象的属性键名类型为且仅为字符串

  ```js
  let obj = {
    a: "大兄弟",
    b: "big bro",
    c: "她好漂亮",
  };
  
  for (let property in obj) {
    console.log(property);
    console.log(typeof property);
  }
  
  /*
  a
  string
  b
  string
  c
  string
  */
  ```

#### 数据类型转换

##### 转为字符串类型

可以将 number 类型, boolean 类型, undefined 类型, null 类型转换为字符串类型

转为字符串类型的**三种**方式

1. 对于 number 类型和 boolean 类型来说, 可以通过 变量名称 **.toString();** 的方式来转换
2. 通过 **String (常量or变量);** 转换为字符串
3. 通过`变量or常量 + ''or""`转换为字符串 // 底层就是调用了 String();

**注意**:

- 数字类型的数字在浏览器控制台输出是蓝色的,字符串类型的数字在浏览器控制台输出是灰色的, 二者**不是**同一类型
  即使在 powershell 中输出结果看上去一毛一样, 其不改变二者不是同一类型的事实
- 常量类型不可改变, 形如 123.toString(); 是错的
- null 和 undefined 类型**不能**通过 .toString 拿到对应(转为)字符串
- null 和 undefined 类型**可以**通过被 String() 包裹来拿到对应(转为)字符串
- String (常量or变量); 的好处在于常量变量都能转

##### 转为数值类型

可以将 string 类型, boolean 类型, undefined 类型, null 类型转为字符串

转为数值类型的**三种**方式

1. 通过 Number(常量or变量); 方式来转换 // 底层是调用了 Number(常量or变量);
2. 通过数学运算中的 +号 和 -号 来转换
3. 通过 parseInt(需要转换的字符串)/parseFloat(需要转换的字符串) // 好处在于能从非纯数字中提取出数字

**注意**: 

- string 类型如果字符串中都是数值, 那么就正常转换

  - 如果字符串是一个空串(零个以上的空格且无其他), 那么转换之后是0
  - 如果字符串中不仅仅是数字, 那么转换之后是NaN

- boolean 类型

  - true转换之后是 1
  - false转换之后是 0

- undefined 类型

  - 转换之后是 NaN

- null 类型

  - 转换之后是 0

    ```js
    // 但这儿有个反直觉的点
    let res = null == 0;
    console.log(res); // false
    // 这说明可转不代表本质相同
    ```

    ```js
    // 还有这个
    let res = undefined == null;
    console.log(res); // true
    // 这俩不是同一基本类型, 转为数值也不同, 但双等运算却返回 true
    ```

  - 总的来说双等挺坑的, 推荐用全等或比较函数比如 isNaN(变量或常量);

- parseInt/parseFloat 都会**从左至右**的提取数值, 一旦遇到非数值就会立即停止
  停止的时候如何还没有提取到数值, 那么就返回 NaN (字符串里有数字但不在最前也会返 NaN)

  - parseInt/parseFloat 都会**将传入的数据当做字符串**来处理

    ```js
    let value = true;
    let num = parseInt(value);
    console.log(num); // NaN
    ```

- 小结:

  - 空字符串/false/null 转换之后都是 0
  - 字符串中不仅仅是数字/undefined 转换之后是 NaN
  - 其它的正常转换
  - 反复接触发现这些规则还是很有道理的

##### 转为布尔类型

可以将 string 类型, number 类型, undefined 类型, null 类型转为字符串

转为布尔类型的**唯一一种**方式: 通过 Boolean(常量or变量)

**注意**:

- string 类型
  只要字符串中有内容都会转换为 true, 只有字符串中没有内容才会转换为 false
  空格**也算**内容
- number 类型
  只有数值是 0 或 NaN 才会转换为 false, 其它的都会转换为 true
- undefined 类型
  转为 false
- null 类型
  转为 false
- 小结: 空字符串/0/NaN/undefined/null 会转换成false, 其它的都是true

#### 关键字与保留字

##### 关键字

什么是关键字？

- 被 JavaScript 语言赋予了**特殊含义的单词**
- 关键字在开发工具中会显示特殊颜色
- 关键字**不能**用作变量名、函数名等
- 关键字严格区分大小写, var和Var前者是关键字, 后者不是
- 只需要记住一点: 在 JavaScript 中**所有的关键字都是<font color="red">小写</font>**的

| 关键字                   |                            |                          |                           |         |
| ------------------------ | -------------------------- | ------------------------ | ------------------------- | ------- |
| break                    | do                         | instanceof               | typeof                    | case    |
| else                     | new                        | var                      | catch                     | finally |
| return                   | void                       | continue                 | for                       | switch  |
| while                    | default                    | if                       | throw                     | delete  |
| in                       | try                        | function                 | this                      | with    |
| debugger                 | false                      | true                     | null                      |         |
| const (ES6 之前是保留字) | import (ES6 之前是保留字)  | export(ES6 之前是保留字) | let(ES6 之前是保留字)     |         |
| class (ES6 之前是保留字) | extends (ES6 之前是保留字) | super (ES6 之前是保留字) | static (ES6 之前是保留字) |         |

##### 保留字

保留字就是 JavaScript 预留的关键字, 它们暂未被实现, 但以后的升级版本中有可能作为关键字

| 保留字    |        |       |           |            |
| --------- | ------ | ----- | --------- | ---------- |
|           | enum   |       |           | implements |
| private   | public | yield | interface | package    |
| protected |        |       |           |            |

#### 标识符

##### 标识符命名规则 (**必须遵守**)

- 只能由26个英文字母的大小写、10个阿拉伯数字0~9、下划线_、美元符号$组成 (其实有中文也不报错	)
- **不能以数字开头**
- 严格区分大小写，比如 test 和 Test 是2个不同的标识符
- 不可以使用关键字、保留字作为标识符

##### 标识符命名规范 (建议遵守)

- 见名知意: 变量的名称要有意义 (名义明确, 有利于提高阅读性)
- 驼峰命名: 首字母小写, 第二个单词起每个单词的首字母大写 (有利于提高阅读性)

#### 注释

1. 什么是JS的注释?
   和 HTML/CSS 的注释一样, 都是用来注解解释某一段程序的含义, 用来提升代码的阅读性的,  方便程序员之间沟通
2. JS注释的格式
   1. 单行注释: // 被注释的内容
      **注意点**: 单行注释的有效范围是从第二个斜杠开始一直直到这一行的末尾, 也就是被注释的内容**不能换行**
   2. 多行注释: /* 被注释的内容 */
      **注意点**: 多行注释的有效范围是从第一颗星开始直到第二颗星结束, 也就是说被注释的内容**可以换行**的
   3. JS中注释的嵌套规则 (只有面试才会问这个)
      1. 单行注释可以嵌套单行注释, 但是必须在一行
      2. 单行注释可以嵌套多行注释, 但是必须在一行
      3. 多行注释可以嵌套单行注释
      4. 多行注释**不可以**嵌套多行注释

```js
// 被注释的内容                                          被注释的内容

/*
被注释的内容
被注释的内容
被注释的内容
*/
```

### 运算符

##### 简介

###### 运算符的分类

按功能可分为: 算术运算符, 位运算符, 关系运算符, 逻辑运算符
按参与运算的操作数的个数分为: 单目运算, 双目运算, 三目运算

###### 运算符的优先级和结合性

\* / % 优先级要高于 + - (小学教的用上错不了)

##### 算术运算符

###### 什么是算数运算符

\+ \- \* / %

###### 算术运算符的注意点

1. **加法**运算的注意点

   - 任何非数值类型的数据在参与加法运算之前, 都会被自动的转换成数值类型之后, 再参与运算
   - 任何数据和 NaN 进行运算, 结果都是 NaN
   - 任何数据和字符串相加, 都会被先**转换成字符串**之后再运算

2. **减法**运算的注意点

   - 任何非数值类型的数据在参与加法运算之前, 都会被自动的转换成数值类型之后, 再参与运算
   - 任何数据和NaN进行运算, 结果都是NaN
   - 任何数据和字符串相减, 都会先**把字符串转换成数值类型**之后再运算

3. **乘法和除法**运算的注意点

   - 和减法运算的注意点一模一样

     ```js
     let a = 5;
     let b = 2;
     let c = a/b;
     console.log(c); // 2.5 
     ```

4. **取模(取余)**运算注意点
   格式: m%n = 余数

   - 如果m>n的, 那么就正常取余
   - 如果m<n的, 那么结果就是m
   - 如果n是0, 那么结果就是 NaN
   - 取余运算结果的正负性, **取决于 m** 而不是 n

##### 赋值运算符

1.什么是赋值运算符?
赋值运算符就是将等号右边的值存储到等号左边的变量中

- **简单类型**的赋值运算符
  =
- **复杂类型**的赋值运算符
  += -= \*= /= %=

赋值运算符的**优先级和结合性**

- 赋值运算符的优先级**低于**算数运算符
- 赋值运算符的结合性是右结合性(**从右至左的计算**)
- 赋值运算符的**左边只能放变量**, 不能放常量

##### 自增自减运算符

1. 什么是自增自减运算符?
   - 自增运算符: ++
   - 自减运算符: --
2. 自增自减运算符的作用
   - 自增运算符: 对一个变量中保存的数据进行 +1 操作
   - 自减运算符: 对一个变量中保存的数据进行 -1 操作
3. 自增和自减写在变量的前面和后面的区别?
   - **写在变量的后面**, 表示变量先参与其它的运算, 然后再自增或者自减
   - **写在变量的前面**, 表示变量先自增或者自减, 然后再参与其它的运算

**注意点**:

1. 自增自减运算符只能出现在**变量**的前面或者后面, 不能出现在常量或者表达式的前面或者后面

2. 什么是表达式?
   **表达式就是用运算符连接在一起有意义有结果的语句**

   - 1 + 1; 表达式
   - a \* 5; 表达式

3. 在企业开发中自增自减运算符**最好单独出现**, 不要出现在表达式中

   ```js
   --666; // 错误的写法
   (1 + 1)++; // 错误的写法
   let res = a++ + b; // 不推荐的写法
   let res = a + b;
   a++; // line3 拆为 line4 和 line5 才是友善的代码
   ```

4. 小结:

   ```js
   // 朴素写法 vs 复杂类型的赋值运算 vs 自增
   let num = 1;
   // num = num + 1;
   // num += 1;
   // num++;
   ```

##### 关系运算符

###### 简介


1. 什么是关系运算符
\> < >= <= \=\= \!\= \=\=\= \!\=\=
2. **关系运算符的返回值是布尔值**, 要么是 true, 要么是 false
  - 如果关系成立, 就返回 true
  - 如果关系不成立, 就返回 false

**注意点**:

1. 对于非数值类型的数据, 会先转换成数值类型, 再进行判断
2. 对于关系运算符来说, 任何数据和 NaN 进行比较, 返回值**都**是 false
3. 如果参与比较的是字符串类型, 那么不会转换成数值类型再比较, 而是直接比较字符对应的 Unicode 编码
4. 特殊比较的结果

###### 双等与三等

\=\=\= 和 \!\=\= 会同时判断取值**和数据类型**

\=\= \!\= 只会判断取值

###### 结合性与优先级

关系运算符都是左结合性 (**从左至右**的运算)

关系运算符中 > < >= <= 的优先级**高于** == != \=\=\= \!\=\=

##### 逻辑运算符

什么是逻辑运算符? (名称?格式?返回值?特点?) (这个的非布尔值返回值把我搞懵逼过)

- 逻辑与: &&
  格式: 条件表达式A && 条件表达式B
  返回值: true false (**还能是数字呢**, 逻辑或同理)
  特点: 一假则假
- 逻辑或: ||
  格式: 条件表达式A || 条件表达式B
  返回值: true false
  特点: 一真则真
- 逻辑非: !
  格式: !条件表达式
  返回值: true false
  特点: 真变假, 假变真

逻辑运算符的优先级和结合性

​    逻辑运算符的结合性是左结合性(**从左至右**的运算)

​    在逻辑运算中 **&& 的优先级高于 ||**

**注意点**:

1. 在逻辑运算中如果不是布尔类型, 那么会先转换成布尔类型, 再参与其它的运算
2. 在逻辑与运算中, 如果参与运算的不是布尔类型, **返回值**有一个**特点**
   格式: 条件A && 条件B
   如果条件A 不成立, 那么就返回条件A
   如果条件A 成立, 无论条件B 是否成立, 都会返回条件B
3. 在逻辑或运算中, 如果参与运算的不是布尔类型, **返回值**有一个特点
   格式: 条件A || 条件B
   如果条件A 成立, 那么就返回条件A
   如果条件A 不成立, 无论条件B 是否成立, 都会返回条件B
4. 在逻辑与运算中,有一个逻辑**短路**现象
   格式: 条件A && 条件B
   由于逻辑与运算的规则是一假则假, 所以只要条件A 是假, 那么条件B 就不会运算
5. 在逻辑或运算中,有一个逻辑短路现象
   格式: 条件A || 条件B
   由于逻辑或运算的规则是一真则真, 所以只要条件A 是真, 那么条件B 就不会运算

##### 逗号运算符

在JavaScript中逗号运算符**一般用于简化代码**



逗号运算符**优先级和结合性**

- 逗号运算符的结合性是左结合性(**从左至右**的运算)
- 逗号运算符的**优先级是所有运算符中最低**的

逗号运算符也是一个运算符, 所以也**有运算符结果**

- 逗号运算符的运算符结果就是最后一个表达式的结果

- 表达式1, 表达式2, 表达式3, ...;

  ```js
  let res = ((1 + 1), (2 + 2), (3 + 3));
  console.log(res); // 6
  // 注意这里不加外面的大括号会报错, 话说这写法蛮清奇的
  ```

##### 三目运算符

什么是三目运算符? 三目运算符又称之为条件运算符

三目运算符格式

- 条件表达式 ? 结果A : 结果B;
- 在三目运算符中当条件为真的时候, 就会返回结果A
- 在三目运算符中当条件为假的时候, 就会返回结果B

**注意点**:

- 在三目运算符中 **? 和 : 不能单独出现**, 要么一起出现, 要么一起不出现

##### 扩展运算符

什么是扩展运算符? 起到折叠或展开元素的作用 (这里元素指的是变量或常量或占位符)

扩展运算符格式

- ...

作用: 

- 把多出来的参数**打包** (只能放最后) (运算符在左边)
- 拼接数组时**展开**数组 (不需要放最后) (运算符在右边)
- 将传递给函数的所有多出来的实参打包到一个数组中 (运算符在右边)

### 流程控制

##### 基本概念

JavaScript 提供**三种**流程结构, 分别是 顺序, 选择, 循环.
1. 顺序结构: 默认的流程结构, 按书写方式从上至下(可没说从左到右)执行每一条语句
2. 选择结构: 对给定的条件进行判断, 再根据判断结果来决定执行哪一段代码
3. 循环结构: 在给定条件成立的情况下, 反复执行某一段代码

##### 选择结构

if, switch

###### if

1. 第一种形式

   ```js
   if(/*条件表达式*/){
      /*条件成立执行的语句*/;
      }
   ```

   特点:
   当条件表达式为真的时候就会执行 {} 中所有的代码, 并且**只会执行一次**

2. 第二种形式

   ```js
   if(/*条件表达式*/){
       /*条件成立执行的语句*/;
   }else{
       /*条件不成立执行的语句*/;
   }
   ```

   特点:
   当条件满足就执行 if 后面 {} 中的代码
   当条件不满足就执行 else 后面 {} 中的代码
   并且两个 {} **只有一个会被执行, 并且只会被执行一次**

3. 第三种形式

   ```js
   if(/*条件表达式A*/){
       /*条件A满足执行的语句*/;
      }else if(/*条件表达式B*/){
       /*条件B满足执行的语句*/;
      }
       ... ...
       else{
       /*前面所有条件都不满足执行的语句*/;
      }   
   ```

   特点:
   会从上至下的依次判断每一个条件表达式, 哪一个条件表达式满足, 就执行哪一个条件表达式后面 {} 中的代码
   如果前面所有的条件表达式都不满足, 就会执行 else 后面 {} 中的代码
   并且众多的大括号**只有一个会被执行, 并且只会执行一次**

**注意点**:

1. 对于非布尔类型的数据, **会先转换成布尔类型再判断**
2. 对于 \=\=/\=\=\= 判断, 建议将常量写在前面, 这样可以在等号写成赋值号时及时报错, 从而避免可能的 bug
3. if或else if或else 后面的大括号都可以省略, 但是省略之后**只有**紧随其后的语句受到控制 (所以**别省略**!)
4. 在 JavaScript 中分号 (;) 也是一条语句 (空语句)
5. if 选择结构可以嵌套使用
6. 当 if 选择结构省略大括号时, else if或else 会自动和距离最近没有被使用的 if 匹配 (这么写代码就该开除)

**最佳实践**:

在企业开发中,
如果条件满足之后**只有一句代码需要执行, 就使用三目运算符**
如果条件满足之后有多句代码需要执行, 就使用选择结构

###### switch

**格式**: (case 有点像 else if, default 有点像 else)

```js
switch(/*表达式*/){
    case /*表达式A*/:
        /*语句A*/;
        break; /* JS 的 break 可不能省嗷 */
    case /*表达式B*/:
        /*语句B*/;
        break;
        ... ...
        default:
        /*前面所有case都不匹配执行的代码*/;
        break;
}
```

特点:

- 会从上至下的依次判断每一个case是否和()中表达式的结果相等, 如果相等就执行对应case后面的代码, 如果前面所有的case都不匹配, 那么就会执行default后面的代码
- 并且所有的 case 和 default **只有一个会被执行, 并且只会被执行一次**

**注意点**:

1. **case 进行的是三等判断**而非双等判断
2. switch() 的 ()中可以是常量也可以是**变量**还可以是**表达式**
3. case后面可以是常量也可以是变量还可以是表达式
4. break的作用是立即结束整个switch语句
   在switch语句中一旦case或者default被匹配, 其它的case和default都会失效 (js 里才是这样)
5. default **不一定**要写在最后
   switch 中的 default 无论放到什么位置, 都会等到所有 case 都不匹配再执行
6. 和 if/else 中的 else 一样, **default 也可以省略**

###### if 还是 switch

- 如果是对区间进行判断, 建议使用 if
- 如果是对几个固定的值的判断, 建议使用 switch
- 原则: 能用 if 就用 if

##### 循环结构

while, do-while, for

###### while

格式:

```js
while(条件表达式){
    /*条件满足执行的语句*/;
}
```

特点:

- **只有**条件表达式为真**才**会执行后面 {} 中的代码
- 大括号中的代码有**可能会被执行多次**

while 的执行流程

1. 首先会判断条件表达式是否为真, 如果为真就执行后面 {} 中的代码
2. 执行完后面 {} 中的代码, 会再次判断条件表达式是否还为真
3. 如果条件表达式还为真, 那么会再次执行后面 {} 中的代码
4. 重复 1~3, **直到条件表达式不为真为止**

书写循环结构的规则

1. 不管三七二十一先写上循环结构的代码
2. 将需要重复执行的代码拷贝到 {} 中
3. 在 () 中指定循环的结束条件

**注意点**:

1. 条件表达式永远为真的循环结构称之为死循环
2. 循环结构中的 {} 我们称之为循环体
3. 和 if 一样对于非 boolean 类型的值, 会先转换为 boolean 类型再判断
4. 和 if 一样, while 后如果只有一条语句它可以省略大括号
5. 和 if 一样, 不能在 () 后面写分号 (;)
6. 最简单死循环写法: while(1);
7. while 括号内**不能为空**, 可以为 null, 啊, 真尼玛绕啊

###### do-while

格式:

```js
do{
    /*需要重复执行的代码*/;
}while(/*条件表达式*/);
```

特点: 

- 无论条件表达式是否为真, 循环体都会被执行一次

  ```js
  while (false){
      console.log("www.it666.com");
  }
  ```

  ```js
  do{
      console.log("www.it666.com");
  }while (false);
  ```

###### while 还是 do-while

1. 大部分情况下 while 循环和 do-while 循环是可以互换的
2. **如果循环体中的代码无论如何都需要先执行一次**, 使用 do-while 循环
3. 其它的情况都建议使用 while 循环

###### for

格式:

```js
for(/*初始化表达式*/; /*条件表达式*/; /*循环后增量表达式*/){
    /*需要重复执行的代码*/;
}
```

特点:

- 和 while 循环的特点一样, 只有条件表达式为真, 才会执行循环体

- 和 while 相比, 少写了一行用于初始化表达式的语句

  ```js
  // 1.初始化表达式
  let num = 1;
  // 2. 条件表达式
  while (num <= 10){
      console.log("发射子弹" + num);
      // 3.循环后增量表达式
      num++;
  }
  ```

  ```js
  // let num = 1;
  for(let num = 1 /*1. 初始化表达式*/; num <= 10 /*2. 条件表达式*/; num++ /*3. 循环后增量表达式*/){
      console.log("发射子弹" + num);
  }
  ```

for 循环的执行流程

1. 首先会执行初始化表达式, 并且只会执行一次
2. 判断条件表达式是否为真, 如果条件表达式为真, 就执行循环体
3. 执行完循环体就会执行循环后增量表达式
4. 重复 2~3, 直到条件表达式不为真为止

**注意点**:

1. 在for循环中"初始化表达式""条件表达式""循环后增量表达式"**都可以不写**, 如果不写就相当于while(1);
2. 其它注意点和 while 循环一样

###### while 还是 for

+ 如果是while循环, 在循环结束之后还可以使用用于控制循环结束的变量

  ```js
  let num = 1;
  while (num <= 10){
      console.log("发射子弹" + num);
      num++;
  }
  console.log(num);
  ```

+ 如果是for循环, 在循环结束之后可以让外界使用, 也可以不让外界使用

  ```js
  for(num = 1; num <= 10; num++){
      console.log("发射子弹" + num);
  }
  console.log(num); // 报错
  ```

  ```js
  let num = 1;
  for(; num <= 10; num++){
      console.log("发射子弹" + num);
  }
  console.log(num); // 11
  ```

###### break 和 continue

**break**

1. 什么是 break 关键字?
   - break 关键字可以用于 switch 语句和循环结构中
   - 在 switch 语句中 break 关键字的作用是立即结束当前的 switch 语句
   - 在循环结构中 break 关键字的作用也是立即结束当前的循环结构
2. 注意点
   - break 关键字后面不能编写任何的语句, 因为永远执行不到
   - **如果在循环嵌套的结构中, break 结束的是当前所在的循环结构(只影响一层嵌套!)**

**continue**

1. 什么是 continue 关键字?
   - continue 关键字**只能用于循环结构**
   - **在循环结构中 continue 关键字的作用是跳过<font color="red">本次循环</font>**, 进入下一次循环
2. continue 关键字的注意点
   - continue 关键字后面和 break 一样, 不能编写其它的代码, 因为执行不到
   - 和 break 一样, 如果 continue 出现在循环嵌套结构中, 只会跳过当前所在的循环

**break 和 continue 区别**

- break 是结束当前**整个**循环
- continue 是结束当前**当次**循环

###### 循环嵌套的规律

在循环嵌套中外循环控制的是行数, 内循环控制的是列数 (当然要配合换行符)

```js
/*

需求: 在界面中输出如下图形
*****
****
***
**
*

*/

for(let i = 0; i < 5; i++){
    console.log(i);
    for(let j = i; j < 5; j++){
        document.write("*");
    }
    document.write("<br>");
}
```

```js
 /*
需求: 在界面中输出如下图形
*
**
***
****
*****

*/
for(let i = 0; i < 5; i++){
    console.log(i);
    for(let j = 0; j <= i; j++){
        document.write("*");
    }
    document.write("<br>");
}
```

### 数组

#### 基本概念

1. 什么是数组?
   数组就是专门用于存储**一组**数据的东西
   **注意点**:
   - 和我们前面学习的 number/ string/ boolean/ null/ undefined不同(基本数据类型)
   - 而数组 (array) 不是基本数据类型, 是引用数据类型(对象类型)
2. 如何**创建**一个数组?
   let 变量名称 = new Array(size);
3. 如何**操作**数据
   - **存储**数据
     变量名称[索引号] = 需要存储的数据;
   - **获取**存储的数据
     变量名称[索引号];

#### 注意点

1. 和其它编程语言不同, 如果数组对应的索引中没有存储数据, **默认存储的就是 undefined**
   其它编程语言中默认保存的是垃圾数据或者 0

2. 和其它编程语言不同, **JavaScript 中访问了数组中不存在的索引<font color="red">不会报错</font>**, 会返回 undefined
   其它编程语言一旦超出索引范围就会报错或者返回脏数据

3. 和其它编程语言不同, 当 JavaScript 中数组的存储空间不够时数组**会自动扩容**
   其它编程语言中数组的大小是固定的

4. 和其它编程语言不同, JavaScript 的数组**可以存储不同类型数据**
   在其它编程语言中数组只能存储相同类型数据 (要么全部都是字符串, 要么全部都是数值等)

5. 和其它编程语言不同, **JavaScript 中数组分配的存储空间<font color="red">不一定</font>是连续的**
   其它语言数组分配的存储空间都是连续的, JavaScript 数组是采用"哈希映射"方式分配存储空间
   什么是哈希映射? 好比字典可以通过偏旁部首找到对应汉字, 我们可以通过索引找到对应空间

   <hr>

   在浏览器中各大浏览器也对数组分配存储空间进行了优化

   - **如果存储的都是相同类型的数据, 那么会尽量分配连续的存储空间**
   - 如果存储的不是相同的数据类型, 那么就不会分配连续的存储空间

6. 创建数组的方式

   1. 通过**构造函数**创建数组

      ```js
      let 变量名称 = new Array(size); // 创建一个指定大小数组
      let 变量名称 = new Array(); // 创建一个空数组
      let 变量名称 = new Array(data1, data2, ...); // 创建一个带数据的数组
      ```

   2. 通过**字面量**创建数组 (开发中数组一般就是用的字面量方式创建)

      ```js
      let 变量名称 = []; // 创建一个空数组
      let 变量名称 = [data1, data2, ...]; //  创建一个带数据的数组
      ```

#### 数组的遍历和解构赋值

##### 遍历

数组的遍历就是**依次取出数组中存储的所有数据**

```js
for(let i = 0; i < arr.length; i++){
    console.log(arr[i]);
}
```

##### 解构赋值

解构赋值是ES6中新增的一种赋值方式

```js
// ES6 以前
let arr = [1, 3, 5];
let a = arr[0];
let b = arr[1];
let c = arr[2];
```

```js
// ES6 新方式
let [a, b, c] = arr;
console.log("a = " + a);
console.log("b = " + b);
console.log("c = " + c);
```

**注意点**:

1. 在数组的解构赋值中, 赋值号左边的格式必须和赋值号右边的**格式一模一样, 才能完全解构**

2. 在数组的解构赋值中, 左边的个数可以和右边的个数不一样, 左边少会丢失, 右边少左边空的值就是 undefined

3. 在数组的解构赋值中, 我们可以给左边指定默认值, 右边少时左边会有默认值

   ```js
   let [a, b = 666, c = 888] = [1];
   ```

4. 在数组的解构赋值中, 如果左边坑位有对应的右边值, 那么默认值会被覆盖

5. 在数组的解构赋值中, 还可以使用 ES6 中新增的扩展运算符来打包剩余的数据

6. 在数组的解构赋值中, 如果使用了扩展运算符, 那么扩展运算符**只能写在最后**

补充:

ES6中新增的**扩展运算符**: ...

```js
// let [a, b] = [1, 3, 5];
let [a, ...b] = [1, 3, 5];
console.log("a = " + a);
console.log(b);
```

#### 数组的增删改查

##### 增 push unshift

需求: 要求在数组最后添加一条数据 (增) push

```js
let arr = ["a", "b", "c"];
arr[3] = "d";
console.log(arr);
```

```js
// push方法可以在数组的最后新增一条数据, 并且会将新增内容之后数组当前的长度返回给我们
let arr = ["a", "b", "c"];
let res = arr.push("d");
console.log(res);
console.log(arr);
```

需求: 要求在数组最后添加两条数据 (增)

```js
// 菜鸟行为
let arr = ["a", "b", "c"];
arr.push("d");
arr.push("e");
console.log(arr);
```

```js
// 数组的 push 方法可以接收 1 个或多个参数
let arr = ["a", "b", "c"];
arr.push("d", "e");
console.log(arr);
```

需求: 要求在数组最前面添加一条数据 (增) unshift

```js
let arr = ["a", "b", "c"];
// arr[-1] = "m"; //  ["a", "b", "c", -1: "m"]
// unshift方法和push方法一样, 会将新增内容之后当前数组的长度返回给我们
let res = arr.unshift("m");
console.log(res);
console.log(arr);
```

需求: 要求在数组最前面添加两条数据 (增)

```js
// 菜鸟行为
let arr = ["a", "b", "c"];
arr.unshift("m");
arr.unshift("w");
console.log(arr);
```

```js
// unshift 方法和 push 方法一样, 可以接收1个或多个参数
let arr = ["a", "b", "c"];
arr.unshift("m", "w");
console.log(arr);
```

##### 删 pop shift splice

需求: 要求删除数组最后一条数据 (删) 用 pop

```js
 // 数组的 pop 方法可以删除数组中的最后一条数据, 并且将删除的数据返回给我们
let arr = ["a", "b", "c"];
let res = arr.pop();
console.log(res);
console.log(arr);
```

需求: 要求删除数组最前面一条数据 (删) 用 shift

```js
// 数组的 shift 方法可以删除数组中的最前面一条数据, 并且将删除的数据返回给我们
let arr = ["a", "b", "c"];
let res = arr.shift();
console.log(res);
console.log(arr);
```

需求: 要求删除数组中索引为1的数据 (删)

```js
// 以下代码的含义: 从索引为1的元素开始删除1条数据
/*
参数1: 从什么位置开始
参数2: 需要删除多少个元素
*/
let arr = ["a", "b", "c"];
arr.splice(1, 1);
console.log(arr);
```

需求: 要求删除数组中除了第0条以外的所有数据 (删)

```js
let arr = ["a", "b", "c"];
arr.splice(1); // 从 1 开始直至结束
console.log(arr);
```
##### 改 splice

需求: 将索引为1的数据修改为m (改)

```js
 let arr = ["a", "b", "c"];
arr[1] = "m";
console.log(arr);
```

需求: 将索引为1的数据修改为d, 索引为2的修改为e (改) splice

```js
 let arr = ["a", "b", "c"];
arr[1] = "d";
arr[2] = "e";
console.log(arr);
```

```js
// 用 .splice()
/*
参数1: 从什么位置开始
参数2: 需要替换多少个元素
参数3开始: 新的内容
*/
arr.splice(1, 2, "d", "e");
console.log(arr);
```

##### 查

需求: 获取数组中索引为1的那个数据 (查, 易过食碗水)

```js
 let arr = ["a", "b", "c"];
console.log(arr[1]);
```

#### 数组的常用方法

toString join concat ...
splice reverse (这行的会改变原有数组, 比较特殊)
indexOf lastIndexOf includes

**注意点**:

- 有的方法第二个参数指的是截取的长度比如 splice (还有字符串方法 substr <这个不改变原数组嗷, 和 splice 不同>)
- 有的方法第二个参数指的是数组索引比如 slice (这种是左闭右开) (还有字符串方法 substring)
- 不要猜, 用到就查文档就最稳

1. 清空数组
   let arr = [1, 2, 3, 4, 5];

   ```
   arr = []
   ```

   ```js
   arr.length = 0;
   ```

   ```js
   arr.splice(0); 
   ```

   ```js
   arr.splice(0, arr.length) 
   ```

2. 如何将数组转换为字符串

   ```js
   let str = arr.toString();
   console.log(str);
   console.log(typeof str);
   ```

3. 将数组转换成指定格式字符串

   ```js
   // join方法默认情况下如果没有传递参数, 就是调用toString();
   // join方法如果传递了参数, 就会将传递的参数作为	元素和元素的连接符号
   let str =  arr.join("+");
   console.log(str);
   console.log(typeof str);
   ```

4. 将两个数组拼接为一个数组
   concat

   ```js
   let arr1 = [1, 3, 5];
   let arr2 = [2, 4, 6];
   // 注意点: 数组不能够使用加号进行拼接, 如果使用加号进行拼接会先转换成字符串再拼接
   // let res = arr1 + arr2; // 1,3,52,4,6 
   let res = arr1.concat(arr2);
   console.log(res);
   
   // 注意点: 不会修改原有的数组, 会生成一个新的数组返回给我们
   console.log(arr1);
   console.log(arr2);
   ```

   扩展运算符

   ```js
   let arr1 = [1, 3, 5];
   let arr2 = [2, 4, 6];
   /*
   注意点:
   扩展运算符在解构赋值中(等号的左边)表示将剩余的数据打包成一个新的数组
   扩展运算符在等号右边, 那么表示将数组中所有的数据解开, 放到所在的位置
   */
   let res = [...arr1, ...arr2]; // let res = [1, 3, 5, 2, 4, 6];
   console.log(res);
   console.log(typeof res);
   
   // 注意点: 不会修改原有的数组, 会生成一个新的数组返回给我们
   console.log(arr1);
   console.log(arr2);
   ```

5. 对数组中的内容进行反转

   ```js
   let arr = [1, 2, 3, 4, 5];
   let res = arr.reverse();
   console.log(res);
   // 注意点: 会修改原有的数组
   console.log(arr);
   ```

6. 截取数组中指定范围内容

   splice, 修改原数组, 返回截取的部分 

   ```js
   const months = ['Jan', 'March', 'April', 'June'];
   months.splice(1, 0, 'Feb');
   // inserts at index 1
   console.log(months);
   // expected output: Array ["Jan", "Feb", "March", "April", "June"]
   
   months.splice(4, 1, 'May');
   // replaces 1 element at index 4
   console.log(months);
   // expected output: Array ["Jan", "Feb", "March", "April", "May"]
   ```

7. 查找元素在数组中的位置

   ```js
   let arr = [1, 2, 3, 4, 5, 3];
   /*
   indexOf方法:
   如果找到了指定的元素, 就会返回元素对应的位置
   如果没有找到指定的元素, 就会返回-1
   默认是从左至右的查找, 一旦找到就会立即停止查找
   */
   let res1 = arr.indexOf(3);
   console.log(res1); // 2
   let res2 = arr.indexOf(6);
   console.log(res2); // -1
   ```

   ```js
   /*
   参数1: 需要查找的元素
   参数2: 从什么位置开始查找
   返回值: 仍是元素在数组中对应位置
   */
   let arr = [1, 2, 3, 4, 5, 3];
   let res = arr.indexOf(3, 4);
   console.log(res)
   ```

   ```js
   /*
   注意点:
   lastIndexOf方法默认是从右至左的查找, 一旦找到就会立即停止查找
   返回值: 仍是元素在数组中对应位置
   */
   let arr = [1, 2, 3, 4, 5, 3];
   let res = arr.lastIndexOf(3);
   console.log(res);
   ```

8. 判断数组中是否包含某个元素

   ```js
   // 通过 indexOf 或 lastIndexOf 的结果, 判断是否是 -1 即可
   let arr = [1, 2, 3, 4, 5];
   // let res = arr.indexOf(8); // -1
   let res = arr.lastIndexOf(8); // -1
   ```

   ```js
   // ES6 中新增了 includes 方法
   let arr = [1, 2, 3, 4, 5];
   let res = arr.includes(4);
   console.log(res); // false
   ```

#### 二维数组

1. 什么是二维数组?
   二维数组就是数组的每一个元素又是一个数组, 我们就称之为二维数组

   ```js
   let arr = [[1, 3], [2, 4]];
   ```

2. 如何操作二维数组?

   1. 如何从二维数组中**获取**数据?
      - 数组名称[二维数组索引]; // 得到一个一维数组
      - 数组名称\[二维数组索引\][一维数组索引]; // 得到一维数组中的元素
   2. 如何往二维数组中**存储**数据?
      - 数组名称[二维数组索引] = 一维数组;
      - 数组名称\[二维数组索引\][一维数组索引] = 值;

3. 遍历二维数组

   ```js
   let arr = [[1, 3], [2, 4]];
   for(let i = 0; i < arr.length; i++){
       let subArray = arr[i];
       // console.log(subArray);
       for(let j = 0; j < subArray.length; j++){
           console.log(subArray[j]);	
       }
   }
   ```




---

函数当然是 ECMAScript 的内容, 但这篇笔记已经超过一万字, 所以匀到 _second 去了